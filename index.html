<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Studywithme</title>

<link href="https://fonts.googleapis.com/css2?family=Patrick+Hand:wght@400&family=Nanum+Pen+Script:wght@400;700&display=swap" rel="stylesheet">

<style>

  /* 다크모드 디폴트 설정 */
  :root{
    --bg-url: url("https://github.com/nihicheli/studywithme/blob/main/image/background%205.png?raw=true");
    --ink: #FBFFF4;
    --ink-sub: rgba(255,255,255,.7); /* 다크모드에 맞춰 잉크 서브색 변경 */
    --line: transparent;
    --top-gap: 12px;
    --content-top: 20vh;

    /* 데스크톱 기본값 */
    --maxh-board: 80vh;
    --maxh-timer: 35vh;
    --maxh-window: 40vh;
    --maxh-char: 50vh;

    --maxw-board: 25vw;
    --maxw-window: 15vw;
    --maxw-timer: 35vw;
    --maxw-char: 70vw;
  }
  :root[data-theme="light"]{
    --ink:#202020;
    --ink-sub:rgba(0,0,0,.7);
    --line:transparent;
  }

  *{box-sizing:border-box}
  html,body{
    height:100%; margin:0; color:var(--ink);
    font-family:"Patrick Hand","Nanum Pen Script",system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,Arial,sans-serif;
    background:#000;
    /* 4. 모바일 폰트 크기 조정 */
    font-size:clamp(10px, 4vw, 14.4px);
    letter-spacing:.02em;
  }

  /* 배경 + 10% 검정 오버레이 */
  #app{
    position:relative; height:100dvh; overflow:hidden;
    background-image:
      linear-gradient(rgba(0,0,0,.10), rgba(0,0,0,.10)),
      var(--bg-url);
    background-size:cover; background-position:center;
  }

  .card{ background: rgba(0,0,0,.02); border: 2px solid var(--line); border-radius: 16px; }
  .panel{ padding: 1rem; }

  button, .pill{
    cursor:pointer; user-select:none; outline:0; touch-action: manipulation;
    background: rgba(255,255,255,.08); color:var(--ink);
    border: 1px solid var(--line);
    border-radius: 999px;
    padding: .6rem .9rem;
    font-weight: 700;
    font-family: inherit;
    font-size: 1rem;
  }
  /* 안쪽 포커스 링 */
  button:focus, .pill:focus, button:focus-visible, .pill:focus-visible{
    outline: none; box-shadow: inset 0 0 0 1px #7C9AFF;
  }
  *{ -webkit-tap-highlight-color: transparent; }
  input, textarea, select{ font-family: inherit; font-size: 1rem; color:#fff }
  :root[data-theme="light"] input, :root[data-theme="light"] textarea, :root[data-theme="light"] select{ color:#222 }


  .row{display:flex; gap:.75rem; align-items:center; flex-wrap:wrap}
  .hwrap{ display:flex; gap:.5rem; align-items:center; overflow-x:auto; }
  .title{font-weight:900; font-size: 1.125rem}

  /* 상단 레이아웃 — 최상단 유지 */
  #topbar{
    position:absolute; left:12px; right:12px; top: var(--top-gap);
    display:grid; grid-template-columns: 1fr auto 1fr; align-items:start; gap:12px;
    z-index: 9000;
  }
  #hamburger{ justify-self:start; width:3.4rem; height:3.4rem; display:grid; place-items:center; font-size:1.2rem; position:relative; z-index:9001; }

  /* 타이머(가운데) */
  #timer{
    justify-self:center; width: min(var(--maxw-timer), 90vw); max-height: var(--maxh-timer);
    display:flex; flex-direction:column; align-items:center; gap:.6rem; text-align:center; overflow:hidden;
  }
  #state{ font-size: 1.25rem; font-weight:900; }
  #time{ font-weight:900; font-size: clamp(2.2rem, 6vw, 4rem); line-height:1; }

  /* Todo list(오른쪽) */
  #board{
    justify-self:end; width: min(var(--maxw-board), 92vw); max-height: var(--maxh-board);
    display:grid; grid-template-rows: auto 1fr auto; overflow:hidden;
  }
  #board .title{margin:0 0 .5rem 0}
  #todo-list{ overflow:auto; padding-right:2px; scrollbar-width: thin; }
  .todo{display:flex; align-items:center; gap:.5rem; padding:.45rem 0; border-bottom:1px solid rgba(255,255,255,.15)}
  .todo:last-child{border-bottom:0}
  .todo .txt{flex:1}
  .todo .del{background:transparent; border:0; color:var(--ink-sub); padding:.3rem .5rem; border-radius:.6rem}
  .todo .del:hover{background:rgba(255,255,255,.12); color:#fff}
  #inputRow{ display:flex; gap:.5rem; align-items:center; padding-top:.6rem; }
  #board input[type="text"]{ width:100%; background:transparent; border: 2px solid var(--line); border-radius: 12px; color:#fff; padding:.5rem .6rem; }

  /* 좌: 창문, 가운데: 캐릭터 */
  #window{ position:absolute; left:2vw; top: var(--content-top); z-index:5; width: min(var(--maxw-window), 90vw); }
  #win-img{ display:block; width:100%; height:auto; max-height: var(--maxh-window); border-radius:16px; border:2px solid var(--line); }

  #character{ 
    position:absolute; left:50%; 
    /* 데스크톱: 중앙 정렬 */
    transform:translateX(-50%); 
    top: calc(var(--content-top) + 20vh); z-index:6; 
    width: min(var(--maxw-char), 96vw); 
    /* 2. 터치 이벤트를 위해 포인터 커서 추가 */
    cursor: pointer;
  }
  #char-img{ 
    /* 디자인 복원: src를 사용하며, 배경은 투명하게 유지 */
    display:block; width:100%; height:auto; max-height: var(--maxh-char); border-radius:18px; border:2px solid var(--line); 
    background:transparent center/contain no-repeat; 
  }

  /* 2. 말풍선 스타일 */
  #fortune-bubble {
    /* 캐릭터 상단 중앙, 타이머 아래에 위치하도록 position:absolute 사용 */
    position: absolute;
    /* 데스크톱/기본 위치: 캐릭터 상단에서 40px 위 */
    top: calc(var(--content-top) + 20vh - 40px); 
    left: 50%;
    transform: translateX(-50%);
    z-index: 9500; /* 타이머(9000)보다 높고, 드로어(10000)보다 낮게 */
    padding: 0.5rem 1rem;
    background: rgba(255, 255, 255, 0.95);
    color: #202020;
    border-radius: 16px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease-in-out, visibility 0.5s;
    white-space: nowrap;
    font-weight: 700;
    font-size: 1.1em;
    font-family: 'Nanum Pen Script', cursive; 
    pointer-events: none; /* 클릭 방지 */
  }
  :root[data-theme="dark"] #fortune-bubble {
    background: rgba(30, 30, 30, 0.95);
    color: #FBFFF4;
    box-shadow: 0 4px 12px rgba(255, 255, 255, 0.1);
  }
  #fortune-bubble.show {
    opacity: 1;
    visibility: visible;
  }
  /* 말풍선 꼬리 (CSS 삼각형) */
  #fortune-bubble::after {
    content: '';
    position: absolute;
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-top: 10px solid rgba(255, 255, 255, 0.95);
  }
  :root[data-theme="dark"] #fortune-bubble::after {
    border-top: 10px solid rgba(30, 30, 30, 0.95);
  }


  /* 하단: 음악패널 */
  #bottombar{
    position:fixed; left:12px; right:12px; bottom: 8px;
    display:flex; gap:12px; justify-content:center; align-items:flex-end; z-index:12;
  }
  #bottombar .card{ flex:1 1 0; min-width:260px; }
  #bottombar h4{ margin:0 0 .5rem 0; font-size: 1.125rem; font-weight:900 }

  /* === 소품 레이어 === */
  /* 요청: 소품 관련 기능 숨김 (주석 처리) */
  #propsLayer{
    position:absolute; inset:0; z-index:7;
    pointer-events:none; /* 기본은 클릭 통과 */
    display: none; /* 소품 레이어 자체 숨김 */
  }
  .prop{
    position:absolute; left:40px; top:40px; width:120px; z-index:80;
    pointer-events:auto; /* 소품 자체는 클릭 가능 */
  }
  .prop img{ width:100%; height:auto; display:block; }
  .draggable { cursor: move; }
  .dragging  { opacity:.92; }
  .resizer{
    position:absolute; right:-8px; bottom:-8px; width:16px; height:16px;
    border-radius:4px; background:rgba(255,255,255,.75);
    border:1px solid rgba(0,0,0,.3);
    display:none; z-index:3;
  }
  .edit-on .resizable .resizer{ display:block; }

  /* 드로어/오버레이 — 절대 최상단 */
  #overlay{ position:fixed; inset:0; background:rgba(0,0,0,.35); opacity:0; pointer-events:none; transition:opacity .2s ease; z-index: 10000; }
  #overlay.show{ opacity:1; pointer-events:auto; }

  #drawer{
    position:fixed; top:0; left:0; bottom:0; width:min(380px, 86vw);
    background:#111; color:#eee; border-right:2px solid var(--line);
    transform:translateX(-100%); transition:transform .24s ease; z-index: 10001;
    display:flex; flex-direction:column; gap:0; overflow-y:auto;
  }
  :root[data-theme="light"] #drawer{ background:#fafafa; color:#222; }
  #drawer.open{ transform:translateX(0) }
  .drawer-head{ display:flex; align-items:center; justify-content:space-between; padding:1rem; border-bottom:2px solid var(--line); }
  .drawer-sec{ padding:1rem; border-bottom:2px dashed rgba(255,255,255,.12); }
  :root[data-theme="light"] .drawer-sec{ border-bottom-color: rgba(0,0,0,.12); }
  .drawer-sec h4{ margin:.2rem 0 .8rem; font-weight:900; }

  .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:.5rem; }
  .drawer-sec input[type="number"], .drawer-sec input[type="text"], .drawer-sec select{
    width:100%; padding:.55rem .7rem; border:2px solid var(--line); border-radius:12px; background:transparent; color:#fff;
  }
  :root[data-theme="light"] .drawer-sec input[type="number"], :root[data-theme="light"] .drawer-sec input[type="text"], :root[data-theme="light"] .drawer-sec select{ color:#222 }
  .fill{ flex:1 }

  .chips{ display:flex; gap:.5rem; align-items:center; flex-wrap: wrap; }
  .chips .pill{ border:1px solid var(--line); border-radius:14px; padding:.5rem .75rem; background:rgba(255,255,255,.06); transition: background .15s ease; }
  .chips .pill:hover{ background:rgba(255,255,255,.12); }
  .list-scroll{ max-height: 40vh; overflow: auto; padding-bottom: .25rem; }
  .list-scroll::-webkit-scrollbar{ width:10px; height:10px; }
  .list-scroll::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.22); border-radius:999px; }
  :root[data-theme="light"] .list-scroll::-webkit-scrollbar-thumb{ background: rgba(0,0,0,.22); }


  a#creditLink{ color:#9db7ff; text-decoration:none; border-bottom:1px dashed #9db7ff; }
  a#creditLink:hover{ opacity:.85; }

  .pill-input{
    width:100%; padding:.6rem .9rem; border:1px solid var(--line); border-radius:999px;
    background: rgba(255,255,255,.08); color:#fff; line-height:1; outline:none;
    transition: background .15s ease, box-shadow .15s ease; -webkit-appearance:none;
  }
  .pill-input::placeholder{ color: rgba(255,255,255,.6); }
  :root[data-theme="light"] .pill-input{ background: rgba(0,0,0,.06); color:#222; }
  :root[data-theme="light"] .pill-input::placeholder{ color: rgba(0,0,0,.5); }
  .pill-input:focus{ box-shadow: inset 0 0 0 3px #7C9AFF; background: rgba(124,154,255,.15); }
  .drawer-sec .row .pill-input{ flex:1; min-width:0; }

  /* 파일 선택을 pill처럼 */
  .input-file-hidden{
    position:absolute; width:0.1px; height:0.1px;
    opacity:0; overflow:hidden; z-index:-1;
  }
  .file-row{ display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
  .file-pill{ display:inline-flex; align-items:center; gap:.5rem; }
  .file-pill .icon{ font-size:1.1rem; line-height:1; }
  #bgFileName, #propFileName{
    max-width: 10rem;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    opacity:.8;
  }
  .bg-thumb{
    width:42px; height:28px; border-radius:8px;
    border:1px solid var(--line); background:#000 center/cover no-repeat;
  }

  /* 강제 가로 보기(세로에서) */
  html.portrait-force, body.portrait-force{
    height:100%;
    overflow-x:auto;
    overflow-y:auto;
  }
  .portrait-force #app{
    width: 100vh;
    height: 100vw;
    transform: rotate(90deg) translateY(-100%);
    transform-origin: top left;
  }

  /* 오른쪽 아래: 실시간 패널 (데스크톱 기본) */
  #presencePanel{
    position: fixed;
    right: 0;
    bottom: calc(8px + 112px);
    width: 25vw;
    max-width: 25vw;
    z-index: 8000;
  }
  #presencePanel .dot{ display:inline-block; width:8px; height:8px; border-radius:999px; margin-right:.4rem; background:#9cccff; }
  #presencePanel .dot.work{ background:#7CFF7C; }
  #presencePanel .dot.break{ background:#FFC66D; }
  /* 1. 실시간 패널 디자인 롤백: study time이 보일 때 공간이 부족하지 않도록 조정 */
  #presenceList .person{ display:flex; justify-content:space-between; gap:.5rem; padding:.25rem 0; }
  #presenceList .nick{ font-weight:700; }

  /* (추가) 하단 중앙 투명 배너 */
  #adBanner{
    position:fixed; left:50%; bottom:0; transform:translateX(-50%);
    width:min(90vw, 970px); height:90px; z-index:1; pointer-events:none;
  }
  /* 3. 배너 이미지 투명도 및 URL 업데이트 */
  #adBanner img{ width:100%; height:100%; opacity:0.2; display:block; } 
  
  /* 배너 위에 텍스트 추가 */
  .ad-inquiry {
    position: absolute;
    top: 5px;
    right: 5px;
    font-size: 0.7rem;
    color: rgba(255, 255, 255, 0.6);
    pointer-events: none;
    font-weight: 500;
  }
  :root[data-theme="light"] .ad-inquiry {
    color: rgba(0, 0, 0, 0.6);
  }

  /* ========== 모바일 전용 오버라이드 (확대) ========== */
  @media (max-width: 720px){
    /* 2. 캐릭터 크기 및 정렬 재조정 */
    #character{ 
        transform: translateX(-50%); 
        width: min(120vw, 96vw); /* 130vw -> 120vw로 조정 (1.2배) */
    } 
    /* 2. 말풍선 위치 수정: 중앙 정렬 개선 */
    #fortune-bubble {
        /* 캐릭터의 중앙 위치 (top: calc(var(--content-top) + 20vh))보다 상단에 위치 */
        top: calc(var(--content-top) + 20vh - 80px); /* 다시 -80px로 미세 조정 */
    }

    :root{
      --content-top: 12vh;
      --maxh-board: 80vh;
      --maxh-timer: 40vh;
      --maxh-window: 40vh;
      --maxh-char: 70vh; 

      /* 1. 모바일에서 Todo List 및 실시간 패널 너비 조정 */
      --maxw-board: 60vw;
      --maxw-window: 30vw;
      --maxw-timer: 86vw;
      --maxw-char: 120vw; /* 130vw -> 120vw로 조정 (크기 재조정) */
    }

    #bottombar{ flex-direction:column; }
    #bottombar .card{ width:100%; }

    /* 1. “지금 공부중” 패널 위치 및 너비 조정 (오른쪽 아래로 더 내림) */
    #presencePanel{
      right: 12px;
      bottom: 120px; /* 하단 음악 컨트롤 패널 위에 위치하도록 조정 */
      width: min(var(--maxw-board), 92vw); /* 60vw 적용 */
      max-width: min(var(--maxw-board), 92vw);
      max-height: 40vh; 
      overflow:auto;
      top: unset;
    }
  }
</style>
</head>
<body>
<div id="app" class="">
  <!-- 오른쪽 아래: 실시간 패널 -->
  <aside id="presencePanel" class="card panel" style="display:none">
    <div class="row" style="justify-content:space-between">
      <!-- 1. "오늘 누적 공부" 타이틀 삭제 -->
      <div class="title" data-lang-key="presence_title">실시간 보기</div>
      <div id="meNick" style="opacity:.8"></div>
    </div>
    <div id="presenceList"></div>
  </aside>

  <!-- 소품 레이어 -->
  <div id="propsLayer"></div>

  <!-- 2. 포춘 쿠키 말풍선 추가 -->
  <div id="fortune-bubble" aria-live="polite"></div>

  <!-- 오버레이 + 드로어 -->
  <div id="overlay"></div>
  <aside id="drawer" aria-label="설정">
    <header class="drawer-head">
      <h3 id="drawerTitle">설정</h3>
      <div class="row">
        <!-- 언어 선택 드롭다운 (중국어 제거, 한국어/영어만) -->
        <select id="languageSelect" class="pill" style="padding:0.6rem 0.7rem; border-radius:12px; flex-shrink:0;">
          <option value="ko">한국어</option>
          <option value="en">English</option>
        </select>
        <button id="themeToggle" class="pill" title="다크/라이트 전환">🌙</button>
        <button id="closeDrawer" class="pill" data-lang-key="close">닫기</button>
      </div>
    </header>

    <!-- 1) 뽀모도로 / 타이머 -->
    <section class="drawer-sec">
      <h4 data-lang-key="timer_pomodoro_title">뽀모도로 / 타이머</h4>
      <div class="row" id="modeRow">
        <label><input type="radio" name="mode" value="pomodoro" checked> <span data-lang-key="pomodoro">뽀모도로</span></label>
        <label><input type="radio" name="mode" value="timer"> <span data-lang-key="timer_up">타이머(카운트업)</span></label>
      </div>
      <div class="grid2" id="pomodoroFields" style="margin-top:.5rem">
        <label><span data-lang-key="focus_min">집중(분)</span>
          <input id="workMin" type="number" min="1" value="25">
        </label>
        <label><span data-lang-key="rest_min">휴식(분)</span>
          <input id="restMin" type="number" min="1" value="5">
        </label>
      </div>
      <label style="display:block; margin-top:.5rem" id="cyclesWrap"><span data-lang-key="cycles_count">사이클 수(N회)</span>
        <input id="totalCycles" type="number" min="1" value="4">
      </label>
      <div class="row" style="margin-top:.6rem">
        <button id="applyPom" class="pill" data-lang-key="apply">적용</button>
      </div>
    </section>

    <!-- 2) 실시간 보기 -->
    <section class="drawer-sec">
      <h4 data-lang-key="presence_title">실시간 보기</h4>
      <div class="row">
        <input id="nickname" class="fill pill-input" placeholder="닉네임(예: do)">
        <button id="applyNick" class="pill" data-lang-key="apply">적용</button>
      </div>
      <div class="row" style="margin-top:.5rem">
        <button id="presenceToggle" class="pill" data-lang-key="public_on">공개: 켜짐</button>
        <button id="shareStudyBtn" class="pill" data-lang-key="share_study_on">내 공부시간 공개: 켜짐</button>
      </div>
      <div id="presenceInfo" style="opacity:.8; margin-top:.4rem">※ 목록엔 최대 5명 표시.</div>
    </section>

    <!-- 3) 음악 -->
    <section class="drawer-sec">
      <h4 data-lang-key="music_style">음악 스타일</h4>
      <div id="moods" class="chips list-scroll"></div>
    </section>

    <section class="drawer-sec">
      <h4 data-lang-key="track_select">곡 선택</h4>
      <div id="tracks" class="chips list-scroll"></div>
    </section>

    <!-- 화면 표시 / 레이아웃 / 배경 / 소품 / 크레딧 -->
    <section class="drawer-sec">
      <h4 data-lang-key="ui_visibility">창문/캐릭터 표시</h4>
      <div class="row">
        <button id="toggleWindow" class="pill" data-lang-key="window_show">창문: 보임</button>
        <button id="toggleCharacter" class="pill" data-lang-key="character_show">캐릭터: 보임</button>
      </div>
    </section>

    <section class="drawer-sec" id="layoutSettings">
      <h4 data-lang-key="screen_settings">화면 설정</h4>
      <div class="row">
        <!-- 배치 편집 버튼 숨김 처리 -->
        <button id="layoutEdit" class="pill" data-lang-key="layout_edit_off" style="display:none;">배치 편집: 꺼짐</button> 
        <button id="layoutReset" class="pill" title="원상복구" data-lang-key="reset_layout">원상복구</button>
        <button id="rotateToggle" class="pill" data-lang-key="rotate_on">회전: 켜짐</button>
      </div>
    </section>

    <section class="drawer-sec">
      <h4 data-lang-key="bg_select">배경 선택</h4>
      <div id="bgChips" class="chips"></div>

      <!-- 파일로 배경 선택 -->
      <div class="file-row" style="margin-top:.5rem">
        <input id="customBgFile" type="file" accept="image/*" class="input-file-hidden">
        <label for="customBgFile" class="pill file-pill" title="배경 이미지 선택">
          <span class="icon">📁</span> <span data-lang-key="bg_file_select">배경 파일 선택</span>
        </label>
        <span id="bgFileName" data-lang-key="not_selected">선택 안 됨</span>
        <span id="bgPreview" class="bg-thumb" aria-hidden="true"></span>
      </div>

      <div class="row" style="margin-top:.5rem">
        <input id="customBgUrl" placeholder="배경 이미지 URL 붙여넣기" class="fill pill-input">
        <button id="applyBg" class="pill" data-lang-key="apply">적용</button>
      </div>
    </section>

    <!-- 소품 관련 섹션 숨김 처리 -->
    <section class="drawer-sec" id="propsSection" style="display:none;">
      <h4 data-lang-key="props">소품</h4>
      <!-- 파일 선택을 URL보다 위로 -->
      <div class="file-row" style="margin-top:.5rem">
        <input id="propFile" type="file" accept="image/*" class="input-file-hidden" />
        <label for="propFile" class="pill file-pill" title="소품 이미지 선택">
          <span class="icon">📁</span> <span data-lang-key="prop_file_select">소품 파일 선택</span>
        </label>
        <span id="propFileName" data-lang-key="not_selected">선택 안 됨</span>
        <button id="propFileAdd" class="pill" data-lang-key="add_file">파일 추가</button>
      </div>
      <div class="row" style="margin-top:.5rem">
        <input id="propUrl" class="fill pill-input" placeholder="소품 이미지 URL">
        <button id="propAdd" class="pill" data-lang-key="add">추가</button>
      </div>

      <div class="chips" style="margin-top:.5rem">
        <button class="pill propPreset" data-url="https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f331.svg">🌱</button>
        <button class="pill propPreset" data-url="https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/2615.svg">☕</button>
        <button class="pill propPreset" data-url="https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f4a1.svg">💡</button>
        <button class="pill propPreset" data-url="https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f4da.svg">📚</button>
      </div>
      <div id="propList" class="list-scroll" style="margin-top:.6rem"></div>
      <div id="propInfo" style="opacity:.8; margin-top:.4rem">※ 소품은 추가 즉시 편집 가능(중앙 최소크기 배치)</div>
    </section>

    <section class="drawer-sec">
      <h4 data-lang-key="credits">Credits</h4>
      <!-- 링크 업데이트 -->
      <a id="creditLink" href="https://dashing-leek-81d.notion.site/Study-with-me-27c4376fbca680629fe3e6e31281b9e2?pvs=74" target="_blank" rel="noopener">Made by do</a>
    </section>
  </aside>

  <!-- 상단: 햄버거 / 타이머 / Todo -->
  <div id="topbar">
    <button id="hamburger" class="card panel" aria-label="메뉴 열기">⋯</button>

    <section id="timer" class="card panel resizable" aria-label="타이머">
      <div id="state" data-lang-key="focusing">집중중</div>
      <div id="time">25:00</div>
      <div class="row">
        <button class="pill" id="startPause" data-lang-key="start">시작</button>
        <button class="pill" id="reset" data-lang-key="reset">리셋</button>
        <button class="pill" id="cyclesBtn" title="사이클 진행 상황">0/4회</button>
      </div>
    </section>

    <section id="board" class="card panel" aria-label="Todo list">
      <div id="todoTitle" class="title">Todo list</div>
      <div id="todo-list"></div>
      <div id="inputRow">
        <input id="todo-input" type="text" placeholder="할 일을 적고 Enter" />
        <button id="todo-add" class="pill" title="추가">＋</button>
      </div>
    </section>
  </div>

  <!-- 메인: 창문 + 캐릭터 -->
  <!-- 2. 포춘 쿠키 말풍선 추가 -->
  <div id="window" class="resizable"><img id="win-img" alt="창문" /></div>
  <div id="character" class="resizable" role="button" tabindex="0"><img id="char-img" alt="캐릭터" /></div>

  <!-- 하단: 음악 -->
  <div id="bottombar">
    <section id="music-controls" class="card panel" aria-label="음악 재생">
      <h4 data-lang-key="music_player">음악 재생</h4>
      <div class="hwrap">
        <button class="pill" id="playPause" data-lang-key="play">재생</button>
        <button class="pill" id="shuffle" data-lang-key="shuffle_off">랜덤: 꺼짐</button>
        <button class="pill" id="repeat" data-lang-key="repeat_off">반복: 꺼짐</button>
      </div>
      <audio id="player" preload="metadata"></audio>
    </section>
  </div>

  <!-- (추후 광고) 하단 중앙 투명 배너 -->
  <div id="adBanner" aria-hidden="true">
    <img alt="ad-placeholder"
      src="https://github.com/nihicheli/studywithme/blob/main/image/Group%209225.png?raw=true"/>
    <span class="ad-inquiry"></span>
  </div>
</div>

<script>
  /* ===== 언어 번역 데이터 (Translation Data) ===== */
  const TRANSLATIONS = {
    en: {
      settings: "Settings",
      close: "Close",
      theme_toggle: "🌙",
      today_study: "Today's Study: ",
      todo_list: "Todo List",
      add_todo_placeholder: "Add a task and Enter",
      delete: "Delete", 
      
      // Timer/Pomodoro
      timer_pomodoro_title: "Timer / Pomodoro",
      pomodoro: "Pomodoro",
      timer_up: "Timer (Count Up)",
      focus_min: "Focus (min)",
      rest_min: "Rest (min)",
      cycles_count: "Cycles (N)",
      apply: "Apply",
      
      // Timer State
      focusing: "Focusing",
      resting: "Resting",
      timer_mode: "Timer Mode",
      start: "Start",
      pause: "Pause",
      reset: "Reset",
      
      // Presence
      presence_title: "Live Presence",
      nickname_placeholder: "Nickname (e.g. do)",
      public_on: "Public: ON",
      public_off: "Public: OFF",
      share_study_on: "Share Time: ON",
      share_study_off: "Share Time: OFF",
      presence_info: "※ Max 5 people shown in list.",
      
      // Music
      music_player: "Music Player",
      music_style: "Music Style",
      track_select: "Track Select",
      play: "Play",
      pause_music: "Pause",
      shuffle_on: "Shuffle: ON",
      shuffle_off: "Shuffle: OFF",
      repeat_off: "Repeat: OFF",
      repeat_one: "Repeat: One",
      repeat_all: "Repeat: All",
      
      // UI/Layout
      ui_visibility: "Visibility",
      window_show: "Window: Show",
      window_hide: "Window: Hide",
      character_show: "Character: Show",
      character_hide: "Character: Hide",
      screen_settings: "Screen Settings",
      layout_edit_off: "Layout Edit: OFF",
      layout_edit_on: "Layout Edit: ON",
      reset_layout: "Reset Layout",
      rotate_on: "Rotate: ON",
      rotate_off: "Rotate: OFF",

      // Background/Props
      bg_select: "Background Select",
      bg_file_select: "Select BG File",
      not_selected: "Not Selected",
      props: "Props",
      prop_file_select: "Select Prop File",
      add_file: "Add File",
      add: "Add",
      prop_info: "※ Props are editable immediately after adding (placed center min size)",
      
      // Credits
      credits: "Credits",
      
      // Presence Status
      status_work: "Focusing",
      status_break: "Resting",
      status_idle: "Idle",
      timer_mode: "Timer Mode",
      no_one_online: "No one online yet",
      hour_short: "h",
      min_short: "m"
    },
    ko: {
      settings: "설정",
      close: "닫기",
      theme_toggle: "🌙",
      today_study: "오늘 누적 공부: ",
      todo_list: "Todo list",
      add_todo_placeholder: "할 일을 적고 Enter",
      delete: "삭제", 
      
      // Timer/Pomodoro
      timer_pomodoro_title: "뽀모도로 / 타이머",
      pomodoro: "뽀모도로",
      timer_up: "타이머(카운트업)",
      focus_min: "집중(분)",
      rest_min: "휴식(분)",
      cycles_count: "사이클 수(N회)",
      apply: "적용",
      
      // Timer State
      focusing: "집중중",
      resting: "휴식중",
      timer_mode: "타이머",
      start: "시작",
      pause: "일시정지",
      reset: "리셋",
      
      // Presence
      presence_title: "실시간 보기",
      nickname_placeholder: "닉네임(예: do)",
      public_on: "공개: 켜짐",
      public_off: "공개: 꺼짐",
      share_study_on: "내 공부시간 공개: 켜짐",
      share_study_off: "내 공부시간 공개: 꺼짐",
      presence_info: "※ 목록엔 최대 5명 표시.",
      
      // Music
      music_player: "음악 재생",
      music_style: "음악 스타일",
      track_select: "곡 선택",
      play: "재생",
      pause_music: "일시정지",
      shuffle_on: "랜덤: 켜짐",
      shuffle_off: "랜덤: 꺼짐",
      repeat_off: "반복: 꺼짐",
      repeat_one: "반복: 한곡",
      repeat_all: "반복: 전체",
      
      // UI/Layout
      ui_visibility: "창문/캐릭터 표시",
      window_show: "창문: 보임",
      window_hide: "창문: 숨김",
      character_show: "캐릭터: 보임",
      character_hide: "캐릭터: 숨김",
      screen_settings: "화면 설정",
      layout_edit_off: "배치 편집: 꺼짐",
      layout_edit_on: "배치 편집: 켜짐",
      reset_layout: "원상복구",
      rotate_on: "회전: 켜짐",
      rotate_off: "회전: 꺼짐",

      // Background/Props
      bg_select: "배경 선택",
      bg_file_select: "배경 파일 선택",
      not_selected: "선택 안 됨",
      props: "소품",
      prop_file_select: "소품 파일 선택",
      add_file: "파일 추가",
      add: "추가",
      prop_info: "※ 소품은 추가 즉시 편집 가능(중앙 최소크기 배치)",
      
      // Credits
      credits: "Credits",
      
      // Presence Status
      status_work: "집중중",
      status_break: "휴식중",
      status_idle: "대기중",
      timer_mode: "타이머",
      no_one_online: "아직 아무도 없어요",
      hour_short: "시간",
      min_short: "분"
    }
  };

  function getTranslation(key) {
      const lang = state.lang;
      return TRANSLATIONS[lang][key] || TRANSLATIONS['en'][key] || key;
  }
  
  function updateTextByLanguage() {
      // 1. HTML lang 속성 업데이트
      document.documentElement.lang = state.lang;
      
      // 2. data-lang-key 속성을 가진 모든 요소 업데이트
      document.querySelectorAll('[data-lang-key]').forEach(el => {
          const key = el.getAttribute('data-lang-key');
          const translation = getTranslation(key);
          // 텍스트 내용 업데이트
          el.textContent = translation;
          
          // input placeholder 업데이트
          if (el.tagName === 'INPUT' && el.id === 'todo-input') {
              el.placeholder = getTranslation('add_todo_placeholder');
          } else if (el.id === 'bgFileName' || el.id === 'propFileName') {
              // '선택 안 됨' 상태 텍스트 처리
              if (el.textContent.trim() === getTranslation('not_selected')) {
                   el.textContent = getTranslation('not_selected');
              }
          }
      });
      
      // 3. 특수 요소 업데이트 (하드코딩된 부분)
      document.getElementById('drawerTitle').textContent = getTranslation('settings');
      document.getElementById('todoTitle').textContent = getTranslation('todo_list');
      
      // 4. 동적으로 업데이트되는 UI 텍스트 재호출
      updateTimerUI();         // 타이머 상태, 시작/일시정지/리셋
      updateCyclesBtn();       // 사이클 버튼
      updateWindowToggleUI();  // 창문 표시
      updateCharacterToggleUI(); // 캐릭터 표시
      updateRepeatUI();        // 반복 모드
      
      // 5. 배치 편집 상태 업데이트 (버튼이 숨겨져 있지만 로직은 유지)
      layoutEditBtn.textContent = getTranslation(window.editOn ? 'layout_edit_on' : 'layout_edit_off');
      
      // 6. 햄버거 버튼 '닫기' 텍스트 업데이트
      document.getElementById('closeDrawer').textContent = getTranslation('close');
      
      // 7. 실시간 보기 정보 업데이트
      document.getElementById('presenceInfo').textContent = getTranslation('presence_info');
  }

  /* ===== 트랙 데이터 (Track Data) ===== */
  const TRACKS = [
    { title: "Bass Meant Jazz",     mood: "Jazz",    url: "https://freepd.com/music/Bass%20Meant%20Jazz.mp3" },
    { title: "Stompin at Midnight", mood: "Jazz",    url: "https://freepd.com/music/Stompin%20at%20Midnight.mp3" },
    { title: "Abstract Anxiety",    mood: "Loud",    url: "https://freepd.com/music/Abstract%20Anxiety.mp3" },
    { title: "Adding the Sun",      mood: "Lo-Fi",   url: "https://freepd.com/music/Adding%20the%20Sun.mp3" },
    { title: "Bleu",                mood: "Lo-Fi",   url: "https://freepd.com/music/Bleu.mp3" },
    { title: "Study and Relax",     mood: "Lo-Fi",   url: "https://freepd.com/music/Study%20and%20Relax.mp3" },
    { title: "Deep Focus",          mood: "Lo-Fi",   url: "https://freepd.com/music/Deep%20Focus. основным" },
    
    /* --- 추가된 곡 (Freepd.com / Incompetech - 상업적 무료) --- */
    { title: "Adventure",           mood: "Lo-Fi",   url: "https://freepd.com/music/Adventure.mp3" }, 
    { title: "Compy Jazz",    mood: "Jazz",    url: "https://freepd.com/music/Compy%20Jazz.mp3" }, 
    { title: "Overture", mood: "Piano",   url: "https://freepd.com/music/Overture.mp3" },
    { title: "Winter",        mood: "Piano", url: "https://freepd.com/music/Winter.mp3" }, 
    
    /* White/Pink/Brown Noise (Public Domain) */
    { title: "White Noise",  mood: "Noise", url: "https://archive.org/download/TenMinutesOfWhiteNoisePinkNoiseAndBrownianNoise/WhiteNoise_64kb.mp3" },
    { title: "Pink Noise",   mood: "Noise", url: "https://archive.org/download/TenMinutesOfWhiteNoisePinkNoiseAndBrownianNoise/PinkNoise_64kb.mp3" },
    { title: "Brown Noise",  mood: "Noise", url: "https://archive.org/download/TenMinutesOfWhiteNoisePinkNoiseAndBrownianNoise/BrownianNoise_64kb.mp3" }
  ];

  /* 창문/캐릭터 0.5s 교차 */
  let charWorkA = "https://github.com/nihicheli/studywithme/blob/main/image/Group%209213.png?raw=true"; // 이미지 1 (집중중)
  let charWorkB = "https://github.com/nihicheli/studywithme/blob/main/image/Group%209214.png?raw=true"; // 이미지 2 (집중중)
  let winWorkA  = "https://github.com/nihicheli/studywithme/blob/main/image/Group%209215.png?raw=true";
  let winWorkB  = "https://github.com/nihicheli/studywithme/blob/main/image/Group%209216.png?raw=true";
  /* 1. 휴식 중일 때 사용할 새로운 이미지 3, 4 */
  let charBreakA = "https://github.com/nihicheli/studywithme/blob/main/image/Group%209222.png?raw=true"; // 이미지 3 (휴식중: 임시 Placeholder)
  let charBreakB = "https://github.com/nihicheli/studywithme/blob/main/image/Group%209224.png?raw=true"; // 이미지 4 (휴식중: 임시 Placeholder)
  let winBreakA  = "https://github.com/nihicheli/studywithme/blob/main/image/Group%209215.png?raw=true";
  let winBreakB  = "https://github.com/nihicheli/studywithme/blob/main/image/Group%209216.png?raw=true";

  let showA = true, blinkTimer = null;
  let fortuneBubbleTimeout = null;
  
  /* [삭제] 이미지 깜빡임 최적화를 위한 BLINK_CACHE 제거 */

  // 2. 따뜻한 메시지 목록
  const FORTUNE_MESSAGES = [
    "오늘의 노력은 내일의 빛이 될 거예요!",
    "잠시 쉬어가도 괜찮아요, 당신은 이미 충분히 잘하고 있어요.",
    "포기하지 않는 마음이 가장 소중한 자산입니다.",
    "지금 이 순간에도 당신은 성장하고 있어요.",
    "작은 성취라도 괜찮아요. 스스로를 칭찬해 주세요!",
    "따뜻한 차 한 잔과 함께 에너지를 채워보세요.",
    "당신의 꿈은 반짝이고 있어요. 조금만 더 힘내요!",
    "가끔은 먼 곳을 바라보는 것도 필요해요.",
    "최고의 공부는 즐기는 공부입니다. 오늘도 화이팅!",
    "천천히 꾸준히 하는 것이 중요해요. 오늘도 화이팅!",
    "숨을 크게 쉬고, 다시 집중해 봐요!",
    "당신은 이 모든 것을 해낼 능력이 있어요.",
    "당신의 오늘은 누군가에게 큰 힘이 되고 있어요.",
    "작은 웃음 하나가 하루를 더 빛나게 해줄 거예요.",
    "마음이 지칠 땐 하늘을 올려다보세요. 위로가 될 거예요.",
    "당신이 걸어온 길은 분명 의미 있는 발자취예요.",
    "누구보다 소중한 건 바로 당신 자신이에요.",
    "조금 늦더라도 괜찮아요. 중요한 건 멈추지 않는 거예요.",
    "어제보다 나은 오늘을 만들고 있는 당신을 응원합니다.",
    "당신의 따뜻한 마음은 언제나 빛나고 있어요."
  ];

  /* ===== 전역 상태 ===== */
  const lsShare = localStorage.getItem("shareStudy");
  const state = {
    mode: localStorage.getItem("mode") || "pomodoro",
    shareStudy: (lsShare === null) ? true : (lsShare === "1"),   // 기본 ON
    isWork: true, running: false,
    workSec: 25*60, restSec: 5*60, remainSec: 25*60,
    interval: null, shuffle: false, playing: false,
    mood: "전체", trackIdx: 0, repeatMode: "off",
    totalCycles: 4, completedCycles: 0,
    /* [유지] 타이머 지연 문제 해결을 위한 타임스탬프 */
    startTimeStamp: 0, // 타이머가 시작된 실제 시점 (ms)
    lastUpdateTimestamp: 0, // studyTimeTotal 업데이트를 위한 마지막 시점 (ms)
    /* 2. 새벽 4시 기점으로 하루 공부시간 누적을 위해 studyTimeTotal 및 lastStudyTime 추가 */
    studyTimeTotal: parseInt(localStorage.getItem("studyTimeTotal") || "0", 10),
    lastStudyTime: parseInt(localStorage.getItem("lastStudyTime") || "0", 10),
    todos: JSON.parse(localStorage.getItem("todos-v1")||"[]"),
    /* 4. 다크모드를 디폴트로 */
    theme: localStorage.getItem("theme") || "dark",
    windowVisible: (localStorage.getItem("ui-window-visible") ?? "1") === "1",
    characterVisible: (localStorage.getItem("ui-character-visible") ?? "1") === "1",
    props: JSON.parse(localStorage.getItem("props-v1")||"[]"),
    rotateOn: (localStorage.getItem("rotateOn") ?? "") === "" ? true : (localStorage.getItem("rotateOn") === "1"),
    // 언어 설정: 한국어를 기본값으로 변경
    lang: localStorage.getItem("lang") || 'ko' 
  };
  window.state = state;

  /* 2. 새벽 4시를 기점으로 공부 시간 초기화 확인 */
  (function checkAndResetDailyStudyTime(){
      const now = new Date();
      const last = new Date(state.lastStudyTime);

      const isNewDay = (now.getFullYear() > last.getFullYear() || now.getMonth() > last.getMonth() || now.getDate() > last.getDate());

      // 오늘 새벽 4시 (4:00:00)
      const resetTime = new Date(now);
      resetTime.setHours(4, 0, 0, 0);

      // (1) 마지막 기록 시점 (last)이 오늘 새벽 4시 이전이고, 현재 시점(now)이 오늘 새벽 4시 이후일 경우
      const shouldReset = (last.getTime() < resetTime.getTime() && now.getTime() >= resetTime.getTime());

      // (2) 또는 날짜 자체가 바뀌었는데, 아직 오늘 4시를 지나지 않았을 경우 (예: 3일 3시에 기록하고 4일 1시에 접속)
      // 이 경우, 전날의 4시와 오늘 4시 사이에 접속했다면 리셋을 건너뛸 수 있으므로, (1) 조건으로 충분합니다.
      // 리셋은 "4시가 되었을 때 처음 접속/액션 시"에만 일어나도록 설계합니다.

      if(shouldReset || (isNewDay && now.getHours() >= 4)){
          // 4시가 지났으므로 리셋
          state.studyTimeTotal = 0;
          localStorage.setItem("studyTimeTotal", "0");
          // lastStudyTime을 현재 시간으로 업데이트 (다시 리셋되지 않도록 방지)
          state.lastStudyTime = now.getTime();
          localStorage.setItem("lastStudyTime", state.lastStudyTime.toString());
      }
      // lastStudyTime이 0이거나 (첫 실행), 4시 리셋 조건이 아니면 현재 시간으로 업데이트만 합니다.
      if (state.lastStudyTime === 0 || shouldReset || isNewDay) {
          state.lastStudyTime = now.getTime();
          localStorage.setItem("lastStudyTime", state.lastStudyTime.toString());
      }
  })();
  
  /* [유지] 현재 정확한 남은 시간 계산 (탭 전환 문제 해결 핵심) */
  function calculateAccurateRemaining() {
    if (!state.running || state.startTimeStamp === 0) return state.remainSec;
    
    const now = Date.now();
    // 타이머 시작 시점 대비 실제 경과 초
    const elapsedRealSeconds = Math.floor((now - state.startTimeStamp) / 1000);
    
    if (state.mode === 'pomodoro') {
        const originalTotalTime = (state.isWork ? state.workSec : state.restSec);
        return originalTotalTime - elapsedRealSeconds;
    } else { // Timer mode (Count-up)
        return elapsedRealSeconds;
    }
  }


  /* 새로고침시 타이머 유지 */
  window.addEventListener('beforeunload', ()=>{
    try{
      // [수정] beforeunload 시 정확한 remainSec를 계산하여 저장
      const snap = {
        mode: state.mode, isWork: state.isWork, running: state.running,
        workSec: state.workSec, restSec: state.restSec, 
        remainSec: calculateAccurateRemaining(), // 정확히 계산된 남은 시간 저장
        totalCycles: state.totalCycles, completedCycles: state.completedCycles
      };
      sessionStorage.setItem('timer-keep', JSON.stringify(snap));
      
      // [수정] 마지막에 studyTimeTotal 업데이트
      if (state.running && (state.mode === 'timer' || state.isWork)) {
        // running 중이었다면, stopTimer에서 누적되었어야 함. 
        // 여기서 다시 한 번 정확한 누적 시간을 계산하여 저장
        const now = Date.now();
        const deltaSeconds = Math.floor((now - state.lastUpdateTimestamp) / 1000);
        if(deltaSeconds > 0) state.studyTimeTotal += deltaSeconds;
      }
      
      localStorage.setItem("studyTimeTotal", state.studyTimeTotal.toString());
      localStorage.setItem("lastStudyTime", Date.now().toString());
    }catch(e){}
  });

  let __resumeAfterReload = false;
  (function restoreTimerFromSession(){
    const saved = sessionStorage.getItem('timer-keep');
    if(!saved) return;
    try{
      const s = JSON.parse(saved);
      state.mode = s.mode || state.mode;
      state.isWork = !!s.isWork;
      state.workSec = +s.workSec || state.workSec;
      state.restSec = +s.restSec || state.restSec;
      // [유지] 저장된 remainSec를 사용 (정확한 시간임)
      state.remainSec = +s.remainSec || state.remainSec; 
      state.totalCycles = +s.totalCycles || state.totalCycles;
      state.completedCycles = +s.completedCycles || 0;
      __resumeAfterReload = !!s.running;
      localStorage.setItem("mode", state.mode);
    }catch(e){}
    sessionStorage.removeItem('timer-keep');
  })();

  const boardList = document.getElementById("todo-list");
  const todoInput = document.getElementById("todo-input");
  const todoAdd   = document.getElementById("todo-add");
  const charImg   = document.getElementById("char-img");
  const winImg    = document.getElementById("win-img");
  const timeEl    = document.getElementById("time");
  const stateEl   = document.getElementById("state");
  const startPause= document.getElementById("startPause");
  const resetBtn  = document.getElementById("reset");
  const cyclesBtn = document.getElementById("cyclesBtn");
  const playPause = document.getElementById("playPause");
  const shuffleBtn= document.getElementById("shuffle");
  const repeatBtn = document.getElementById("repeat");
  const player    = document.getElementById("player");
  const fortuneBubble = document.getElementById("fortune-bubble");
  const characterBox = document.getElementById("character");

  const overlay   = document.getElementById("overlay");
  const drawer    = document.getElementById("drawer");
  const hamburgerBtn = document.getElementById("hamburger");
  const closeDrawer  = document.getElementById("closeDrawer");
  const themeToggle  = document.getElementById("themeToggle");
  const moodsWrap    = document.getElementById("moods");
  const tracksWrap   = document.getElementById("tracks");

  const workMin      = document.getElementById("workMin");
  const restMin      = document.getElementById("restMin");
  const totalCyclesInput = document.getElementById("totalCycles");
  const applyPom     = document.getElementById("applyPom");

  const modeRadios   = document.querySelectorAll('input[name="mode"]');
  const pomodoroFields = document.getElementById("pomodoroFields");
  const cyclesWrap   = document.getElementById("cyclesWrap");

  const bgChips      = document.getElementById("bgChips");
  const customBgUrl  = document.getElementById("customBgUrl");
  const applyBg      = document.getElementById("applyBg");
  const customBgFile = document.getElementById("customBgFile");
  const bgFileName   = document.getElementById("bgFileName");
  const bgPreview    = document.getElementById("bgPreview");

  const toggleWindowBtn    = document.getElementById("toggleWindow");
  const toggleCharacterBtn = document.getElementById("toggleCharacter");
  const windowBox          = document.getElementById("window");
  
  const layoutEditBtn  = document.getElementById("layoutEdit");
  const layoutResetBtn = document.getElementById("layoutReset");
  const rotateToggle   = document.getElementById("rotateToggle");

  const propsLayer   = document.getElementById("propsLayer");
  const propUrl      = document.getElementById("propUrl");
  const propAdd      = document.getElementById("propAdd");
  const propFile     = document.getElementById("propFile");
  const propFileAdd  = document.getElementById("propFileAdd");
  const propFileName = document.getElementById("propFileName");
  const propList     = document.getElementById("propList");
  const propPresets  = document.querySelectorAll(".propPreset");
  const propsSection = document.getElementById("propsSection"); // 소품 섹션
  const layoutSettings = document.getElementById("layoutSettings"); // 화면 설정 섹션

  const presencePanel = document.getElementById("presencePanel");
  const meNickEl      = document.getElementById("meNick");
  const presenceList  = document.getElementById("presenceList");
  const presenceToggle= document.getElementById("presenceToggle");
  const nicknameInput = document.getElementById("nickname");
  const languageSelect= document.getElementById("languageSelect"); // 새 언어 선택 요소
  const applyNick     = document.getElementById("applyNick"); // 닉네임 적용 버튼

  /* 드로어 여닫기 보장 함수 (오버레이 잔존 방지) */
  function openDrawerNow(){
    drawer.classList.add("open");
    overlay.classList.add("show");
    overlay.style.pointerEvents = "auto";
  }
  function closeDrawerNow(){
    drawer.classList.remove("open");
    overlay.classList.remove("show");
    overlay.style.pointerEvents = "none";
  }

  function applyTheme(t){
    document.documentElement.setAttribute("data-theme", t);
    themeToggle.textContent = (t==="dark" ? "🌙" : "☀️");
    localStorage.setItem("theme", t);
  }

  function getStudyTimeToday(){
    // 누적 공부 시간 (초)을 포맷하여 반환
    return fmt(state.studyTimeTotal);
  }

  // 2. 포춘 쿠키 메시지 표시 함수
  function showFortuneMessage(){
    clearTimeout(fortuneBubbleTimeout);
    
    // 1. 메시지 선택
    const message = FORTUNE_MESSAGES[Math.floor(Math.random() * FORTUNE_MESSAGES.length)];
    
    // 2. 메시지 설정 및 표시 (fade-in)
    fortuneBubble.textContent = message;
    fortuneBubble.classList.remove('show');
    // DOM 업데이트를 보장한 후 클래스 추가
    setTimeout(() => {
        fortuneBubble.classList.add('show');
    }, 50);

    // 3. 3초 후 사라짐 (fade-out)
    fortuneBubbleTimeout = setTimeout(() => {
        fortuneBubble.classList.remove('show');
    }, 3000);
  }


  /* [복원] 이미지 깜빡임 로직 분리 및 업데이트 - src 변경 방식 사용 */
  function updateCharacterAndWindowImages() {
    // running 상태 또는 isWork 상태에 따라 사용할 이미지 쌍을 결정
    let charA, charB, winA, winB;

    if (state.running && state.isWork) {
        // 타이머가 돌아가고 집중중일 때: Work 이미지 1, 2 사용
        charA = charWorkA; charB = charWorkB;
        winA  = winWorkA;  winB  = winWorkB;
    } else {
        // 타이머가 돌아가지 않거나, 휴식 중일 때
        charA = charBreakA; charB = charBreakB;
        winA  = winBreakA;  winB  = winBreakB;
    }

    // [복원] src 속성을 직접 변경하는 방식 사용
    showA = !showA;
    charImg.src = showA ? charA : charB;
    winImg.src  = showA ? winA  : winB;
  }


  function init(){
    /* 4. 다크모드를 디폴트로 - 이미 state.theme='dark'로 기본 설정되어있음 */
    applyTheme(state.theme);
    
    // 언어 선택 기능 초기화
    languageSelect.value = state.lang;
    languageSelect.addEventListener('change', (e) => {
        state.lang = e.target.value;
        localStorage.setItem('lang', state.lang);
        updateTextByLanguage();
    });

    hamburgerBtn.addEventListener("click", openDrawerNow);
    closeDrawer  .addEventListener("click", closeDrawerNow);
    overlay      .addEventListener("click", closeDrawerNow);
    themeToggle  .addEventListener("click", ()=>{ state.theme = (state.theme==="dark")?"light":"light"===state.theme?"dark":"dark"; applyTheme(state.theme); });

    modeRadios.forEach(r=>{
      r.checked = (r.value === state.mode);
      r.addEventListener('change', ()=>{
        state.mode = r.value;
        localStorage.setItem("mode", state.mode);
        if(state.mode==='timer'){
          state.isWork = true; state.remainSec = 0; state.completedCycles = 0;
        }else{
          state.isWork = true; state.remainSec = state.workSec; state.completedCycles = 0;
        }
        stopTimer(); updateCyclesBtn(); updateTimerUI(); refreshModeFields();
      });
    });
    refreshModeFields();

    workMin.value = Math.round(state.workSec/60);
    restMin.value = Math.round(state.restSec/60);
    totalCyclesInput.value = state.totalCycles;
    updateCyclesBtn();

    const BG_PRESETS = [
      "https://github.com/nihicheli/studywithme/blob/main/image/background%205.png?raw=true",
      "https://github.com/nihicheli/studywithme/blob/main/image/background%206.png?raw=true",
      "https://github.com/nihicheli/studywithme/blob/main/image/background%202.png?raw=true",
      "https://github.com/nihicheli/studywithme/blob/main/image/background%204.png?raw=true",
      "https://github.com/nihicheli/studywithme/blob/main/image/background%203.png?raw=true"
    ];
    BG_PRESETS.forEach((url,i)=>{
      const btn=document.createElement("button");
      btn.className="pill";
      btn.innerHTML=`<img src="${url}" alt="bg${i}" style="width:42px;height:28px;object-fit:cover;border-radius:8px;vertical-align:middle;margin-right:.4rem;border:1px solid var(--line)"> 배경 ${i+1}`;
      btn.addEventListener("click", ()=> setBackground(url));
      bgChips.appendChild(btn);
    });
    applyBg.addEventListener("click", ()=>{ const url=(customBgUrl.value||"").trim(); if(url) setBackground(url); });
    function setBackground(url){ document.documentElement.style.setProperty("--bg-url", `url("${url}")`); }

    customBgFile?.addEventListener("change", ()=>{
      // [오류 수정] customBgBgFile.files[0] -> customBgFile.files[0]
      const file = customBgFile.files && customBgFile.files[0]; 
      if(!file) return;
      bgFileName.textContent = file.name;
      const reader = new FileReader();
      reader.onload = (e)=>{
        const dataUrl = e.target.result;
        bgPreview.style.backgroundImage = `url("${dataUrl}")`;
        setBackground(dataUrl);
      };
      reader.readAsDataURL(file);
    });

    /* [재수정] 이미지 깜빡임 로직: 500ms setInterval 복원 (타이머 로직과 독립) */
    updateCharacterAndWindowImages(); // 초기 이미지 설정 (src 설정)
    if (blinkTimer) clearInterval(blinkTimer); // 혹시 모를 중복 방지
    blinkTimer = setInterval(updateCharacterAndWindowImages, 500);


    renderTodos();
    todoAdd.addEventListener("click", addTodo);
    todoInput.addEventListener("keydown", (e)=>{ if(e.key==="Enter") addTodo(); });

    initMoodsAndTracks();

    player.addEventListener("ended", onEnded);
    player.addEventListener("error", ()=>{
      const list = filteredTrackIdxs();
      if(list.length){
        const curPos = list.indexOf(state.trackIdx);
        const n = list[(curPos+1) % list.length];
        selectTrack(n,true);
      }
    });
    repeatBtn.addEventListener("click", toggleRepeat);

    applyPom.addEventListener("click", ()=>{
      if(state.mode === 'pomodoro'){
        const wm=Math.max(1,parseInt(workMin.value||"25",10));
        const rm=Math.max(1,parseInt(restMin.value||"5",10));
        const tc=Math.max(1,parseInt(totalCyclesInput.value||"4",10));
        state.workSec=wm*60; state.restSec=rm*60; state.totalCycles=tc;
        state.isWork=true; state.remainSec=state.workSec; state.completedCycles=0;
      }else{
        state.isWork=true; state.remainSec=0; state.totalCycles=1; state.completedCycles=0;
      }
      stopTimer(); updateCyclesBtn(); updateTimerUI();
    });
    cyclesBtn.addEventListener("click", ()=>{ state.completedCycles=0; updateCyclesBtn(); });

    updateWindowToggleUI();
    updateCharacterToggleUI();
    toggleWindowBtn.addEventListener("click", ()=>{
      state.windowVisible = !state.windowVisible;
      windowBox.style.display = state.windowVisible ? "" : "none";
      localStorage.setItem("ui-window-visible", state.windowVisible ? "1" : "0");
      updateWindowToggleUI();
    });
    toggleCharacterBtn.addEventListener("click", ()=>{
      state.characterVisible = !state.characterVisible;
      characterBox.style.display = state.characterVisible ? "" : "none";
      localStorage.setItem("ui-character-visible", state.characterVisible ? "1" : "0");
      updateCharacterToggleUI();
    });

    // 2. 캐릭터 터치 시 말풍선 표시 이벤트 추가
    characterBox.addEventListener('click', showFortuneMessage);
    characterBox.addEventListener('touchstart', showFortuneMessage);

    setupLayoutDrag();

    /* 회전(간소화: 스케일 호출 제거) */
    function setRotate(on){
      state.rotateOn = !!on;
      localStorage.setItem('rotateOn', state.rotateOn ? "1" : "0");
      rotateToggle.textContent = getTranslation(state.rotateOn ? 'rotate_on' : 'rotate_off');
      applyRotateState();
    }
    function isSmartphone(){
      const ua = navigator.userAgent || navigator.vendor || window.opera || "";
      const looksMobileUA = /iPhone|iPod|Android.+Mobile|Mobi/i.test(ua);
      const smallViewport = Math.min(window.innerWidth, window.innerHeight) <= 820; 
      return looksMobileUA && smallViewport;
    }
    function applyRotateState(){
      const portrait = window.innerHeight > window.innerWidth;
      document.documentElement.classList.toggle('portrait-force', state.rotateOn && portrait);
    }
    rotateToggle.addEventListener('click', ()=> setRotate(!state.rotateOn));
    window.addEventListener('resize', applyRotateState);
    window.addEventListener('orientationchange', ()=> setTimeout(applyRotateState, 50));
    // 저장된 값이 없으면: 스마트폰 = 기본 ON, 그 외 = 기본 OFF
    const savedRotate = localStorage.getItem('rotateOn');
    if (savedRotate === null) {
      setRotate(isSmartphone());        // 스마트폰이면 true, 아니면 false
    } else {
      setRotate(savedRotate === '1');   // 사용자가 이전에 선택한 값 유지
    }

    /* 소품 프리셋 */
    document.querySelectorAll('.propPreset').forEach(btn=>
      btn.addEventListener('click', ()=>{
        addProp(btn.dataset.url, true, {autoEdit:true});
        closeDrawerNow();           /* 오버레이 잔존 방지 */
      })
    );

    /* (개선) 소품 파일 선택: 모바일에서도 '선택 즉시 추가' */
    propFile.addEventListener('change', ()=>{
      const f = propFile.files && propFile.files[0];
      propFileName.textContent = f ? f.name : getTranslation('not_selected');
      if(f){
        const url = URL.createObjectURL(f);
        addProp(url, true, {autoEdit:true});
        // iOS에서 포커스/버튼 문제 방지: 드로어와 오버레이를 확실히 닫기
        closeDrawerNow();
        // 파일 입력 리셋 (같은 파일 재첨부 가능)
        setTimeout(()=>{ propFile.value=""; propFileName.textContent=getTranslation('not_selected'); }, 0);
      }
    });

    /* (유지) 별도의 '파일 추가' 버튼도 제공 */
    propFileAdd.addEventListener('click', ()=>{
      const f = propFile.files && propFile.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      addProp(url, true, {autoEdit:true});
      propFile.value = ""; propFileName.textContent = getTranslation('not_selected');
      closeDrawerNow();
    });

    propAdd.addEventListener('click', ()=>{
      const u=(propUrl.value||"").trim(); if(!u) return;
      addProp(u, true, {autoEdit:true});
      propUrl.value="";
      closeDrawerNow();
    });

    renderProps();

    function refreshShareStudyUI(){
      shareStudyBtn.textContent = getTranslation(state.shareStudy ? 'share_study_on' : 'share_study_off');
    }
    shareStudyBtn.addEventListener("click", ()=>{
      state.shareStudy = !state.shareStudy;
      localStorage.setItem('shareStudy', state.shareStudy ? "1" : "0");
      refreshShareStudyUI();
      window.__presence_broadcastNow?.();
    });
    refreshShareStudyUI();
    
    // 닉네임 적용 버튼 이벤트
    applyNick.addEventListener('click', goOnline);


    // 언어 설정 후 마지막에 UI 텍스트 일괄 업데이트
    updateTextByLanguage();
    updateTimerUI();
    if(__resumeAfterReload){ startTimer(); }
  }

  function refreshModeFields(){
    const isPom = (state.mode === 'pomodoro');
    pomodoroFields.style.display = isPom ? '' : 'none';
    cyclesWrap.style.display     = isPom ? '' : 'none';
    stateEl.textContent = isPom ? (state.isWork?getTranslation('focusing'):getTranslation('resting')) : getTranslation('timer_mode');
  }

  /* [유지] Todo List 렌더링 최적화: DocumentFragment 사용 */
  function renderTodos(){
    boardList.innerHTML = "";
    if(state.todos.length === 0) return;
    
    const fragment = document.createDocumentFragment();

    state.todos.forEach((t,idx)=>{
      const row=document.createElement("div"); row.className="todo";
      const cb=document.createElement("input"); cb.type="checkbox"; cb.checked=!!t.done;
      cb.addEventListener("change",()=>{ t.done=cb.checked; persistTodos(); renderTodos(); });
      const tx=document.createElement("div"); tx.className="txt"; tx.textContent=t.text;
      tx.style.textDecoration=t.done?"line-through":"none"; tx.style.opacity=t.done?".6":"1";
      const del=document.createElement("button"); del.className="del"; del.textContent=getTranslation('delete'); 
      del.addEventListener("click",()=>{ state.todos.splice(idx,1); persistTodos(); renderTodos(); });
      row.append(cb,tx,del); 
      fragment.appendChild(row);
    });
    
    boardList.appendChild(fragment);
  }
  function persistTodos(){ localStorage.setItem("todos-v1", JSON.stringify(state.todos)); }
  function addTodo(){ const v=todoInput.value.trim(); if(!v) return; state.todos.push({text:v,done:false}); todoInput.value=""; persistTodos(); renderTodos(); }

  function MOODS(){ return ["전체","Lo-Fi","Jazz","Loud","Piano","Ambient","Noise"]; } /* Ambient 추가 */
  function filteredTrackIdxs(){
    if(state.mood==="전체") return TRACKS.map((_,i)=>i);
    return TRACKS.map((t,i)=> t.mood===state.mood ? i : -1).filter(i=>i>=0);
  }
  function initMoodsAndTracks(){
    moodsWrap.innerHTML = "";
    const moodFragment = document.createDocumentFragment();
    MOODS().forEach(m=>{
      const b=document.createElement("button");
      b.className="pill"; b.textContent=m; b.dataset.mood=m;
      b.addEventListener("click", ()=>{ state.mood=m; highlightMood(); renderTracks(); });
      moodFragment.appendChild(b);
    });
    moodsWrap.appendChild(moodFragment);
    highlightMood();
    renderTracks(true);
  }
  /* [유지] 음악 트랙 렌더링 최적화: DocumentFragment 사용 */
  function renderTracks(initial=false){
    tracksWrap.innerHTML = "";
    const idxs = filteredTrackIdxs();
    
    const fragment = document.createDocumentFragment();
    idxs.forEach(idx=>{
      const t = TRACKS[idx];
      const b=document.createElement("button");
      b.className="pill"; b.textContent=t.title; b.dataset.idx=idx;
      b.addEventListener("click", ()=> selectTrack(idx, state.playing));
      fragment.appendChild(b);
    });
    tracksWrap.appendChild(fragment);

    if(!idxs.includes(state.trackIdx) && idxs.length){
      selectTrack(idxs[0], false);
    }
    highlightTrack();
    if(initial){ selectTrack(idxs[0] ?? 0, false); }
  }
  function selectTrack(idx, autoplay=false){ state.trackIdx=idx; player.src=TRACKS[idx].url; highlightTrack(); if(autoplay) tryPlay(); }
  function tryPlay(){ player.play().then(()=>{ state.playing=true; playPause.textContent=getTranslation('pause_music'); }).catch(()=>{}); }
  function highlightMood(){ [...moodsWrap.children].forEach(b=>{ b.style.boxShadow = (b.dataset.mood===state.mood) ? "inset 0 0 0 1px #7C9AFF" : "none"; }); }
  function highlightTrack(){ [...tracksWrap.children].forEach(b=>{ b.style.boxShadow = (+b.dataset.idx===state.trackIdx) ? "inset 0 0 0 1px #7C9AFF" : "none"; }); }
  document.getElementById("playPause").addEventListener("click", ()=>{
    if(!player.src) selectTrack(state.trackIdx,false);
    if(!state.playing){ tryPlay(); } else { player.pause(); state.playing=false; playPause.textContent=getTranslation('play'); }
  });
  document.getElementById("shuffle").addEventListener("click", ()=>{ state.shuffle=!state.shuffle; shuffleBtn.textContent=getTranslation(state.shuffle?'shuffle_on':'shuffle_off'); });
  function toggleRepeat(){ 
      const order=["off","one","all"]; 
      const i=order.indexOf(state.repeatMode); 
      state.repeatMode=order[(i+1)%order.length]; 
      updateRepeatUI(); 
  }
  function getRepeatKey(mode) {
      if (mode === 'one') return 'repeat_one';
      if (mode === 'all') return 'repeat_all';
      return 'repeat_off';
  }
  function updateRepeatUI(){ 
      repeatBtn.textContent=getTranslation(getRepeatKey(state.repeatMode)); 
      player.loop=(state.repeatMode==="one"); 
  }
  updateRepeatUI();
  function onEnded(){
    if(state.repeatMode==="one") return;
    const list = filteredTrackIdxs();
    if(state.shuffle){
      let n = state.trackIdx;
      if(list.length>1){
        while(n===state.trackIdx) n = list[Math.floor(Math.random()*list.length)];
      }
      selectTrack(n,true); return;
    }
    if(state.repeatMode==="all" && list.length){
      const cur = list.indexOf(state.trackIdx);
      const n = list[(cur+1)%list.length];
      selectTrack(n,true); return;
    }
    state.playing=false; playPause.textContent=getTranslation('play');
  }

  function fmt(sec){
    const s=Math.max(0,sec|0);
    const h=Math.floor(s/3600), m=Math.floor((s%3600)/60), ss=s%60;
    const mm=m.toString().padStart(2,'0'); const s2=ss.toString().padStart(2,'0');
    return h>0?`${h}:${mm}:${s2}`:`${mm}:${s2}`;
  }
  function updateTimerUI(){
    // [유지] UI 업데이트 시 calculateAccurateRemaining을 사용하여 정확한 남은 시간 반영
    state.remainSec = calculateAccurateRemaining(); 
    timeEl.textContent=fmt(state.remainSec);
    
    let statusKey = 'timer_mode';
    if(state.mode === 'pomodoro') {
        statusKey = state.isWork ? 'focusing' : 'resting';
    }
    stateEl.textContent=getTranslation(statusKey);
    
    startPause.textContent=getTranslation(state.running?'pause':'start');
    
    window.__presence_broadcastNow?.();
  }
  function beep(){ try{ const ctx=new (window.AudioContext||window.webkitAudioContext)(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.connect(g); g.connect(ctx.destination);
    o.type="sine"; o.frequency.value=880; g.gain.setValueAtTime(.0001,ctx.currentTime); g.gain.exponentialRampToValueAtTime(.3,ctx.currentTime+.01); o.start(); g.gain.exponentialRampToValueAtTime(.0001,ctx.currentTime+.25); o.stop(ctx.currentTime+.3);}catch{} }
  
  /* [유지] 실시간 타임스탬프 기반의 Timer Tick 함수 (SetTimeout 재귀) */
  function timerTick() {
    if (!state.running) {
      return;
    }

    const now = Date.now();
    // 타이머 시작 시점 대비 실제 경과 초
    const elapsedRealSeconds = Math.floor((now - state.startTimeStamp) / 1000);
    let shouldAccumulate = false;
    let nextRemainSec = 0;

    if (state.mode === 'pomodoro') {
      const originalTotalTime = (state.isWork ? state.workSec : state.restSec);
      nextRemainSec = originalTotalTime - elapsedRealSeconds;
      
      if (nextRemainSec <= 0) {
        // 사이클 전환 처리
        beep();
        const wasWork = state.isWork;
        state.isWork = !state.isWork;

        // 초과된 시간을 보정하여 새로운 phase의 startTimeStamp 설정
        state.startTimeStamp = now + nextRemainSec * 1000; 
        
        state.remainSec = state.isWork ? state.workSec : state.restSec; // 다음 phase의 초기값
        
        if (state.isWork && !wasWork){
          state.completedCycles = Math.min(state.totalCycles, state.completedCycles + 1);
          updateCyclesBtn();
          if (state.completedCycles >= state.totalCycles) { stopTimer(); return; }
        }
        // updateCharacterAndWindowImages(); // [삭제] 그림 애니메이션은 별도의 500ms 타이머가 담당
        shouldAccumulate = true; // 새로운 페이즈 시작 시도
      } else {
        state.remainSec = nextRemainSec;
        if(state.isWork) shouldAccumulate = true;
      }
    } else { // Timer mode (Count-up)
      state.remainSec = elapsedRealSeconds;
      shouldAccumulate = true;
    }

    // 누적 공부 시간 업데이트 (실제 경과 시간 기반)
    if(shouldAccumulate && state.lastUpdateTimestamp > 0) {
        const deltaSeconds = Math.floor((now - state.lastUpdateTimestamp) / 1000);
        if (deltaSeconds > 0) state.studyTimeTotal += deltaSeconds;
    }
    state.lastUpdateTimestamp = now;

    updateTimerUI();
    // updateCharacterAndWindowImages(); // [삭제] 그림 애니메이션은 별도의 500ms 타이머가 담당
    
    // [유지] 1초마다 페이지 제목 업데이트 (지연 감소)
    document.title = `${fmt(state.remainSec)} • Studywithme`;

    // 다음 틱을 정확히 1초 후에 실행되도록 스케줄링
    const timeSinceLastSecond = (now - state.startTimeStamp) % 1000;
    const nextTick = 1000 - timeSinceLastSecond;
    
    if(state.interval) clearTimeout(state.interval);
    state.interval = setTimeout(timerTick, nextTick);
  }

  /* [유지] 타이머 시작 (setInterval 대신 setTimeout 재귀 시작) */
  function startTimer(){
    if(state.running) return;
    
    // 남은 시간(remainSec)을 기준으로 startTimeStamp 역계산
    const totalTimeInSeconds = (state.mode === 'pomodoro' && state.isWork) 
                                ? state.workSec : state.remainSec; // count-up은 remainSec이 경과 시간
    
    state.startTimeStamp = Date.now() - (totalTimeInSeconds - state.remainSec) * 1000;
    state.lastUpdateTimestamp = Date.now(); // Accumulation 시작 시점

    state.running=true;
    updateTimerUI();
    // updateCharacterAndWindowImages(); // [삭제] 그림 애니메이션은 별도의 500ms 타이머가 담당

    // 첫 번째 틱을 바로 시작
    if(state.interval) clearTimeout(state.interval);
    state.interval = setTimeout(timerTick, 0); 
    
    window.__presence_broadcastNow?.();
  }
  
  /* [유지] 타이머 중지 (정확한 최종 시간 반영) */
  function stopTimer(){
    if(!state.running) return;
    state.running=false;
    
    if(state.interval){ 
        clearTimeout(state.interval); 
        state.interval=null; 
    }
    
    // 멈추는 시점의 정확한 remainSec 및 studyTimeTotal 반영
    const now = Date.now();
    const elapsedRealSeconds = Math.floor((now - state.startTimeStamp) / 1000);
    const deltaSeconds = Math.floor((now - state.lastUpdateTimestamp) / 1000);
    
    if (state.mode === 'pomodoro') {
      const originalTotalTime = (state.isWork ? state.workSec : state.restSec);
      state.remainSec = originalTotalTime - elapsedRealSeconds;
      if(state.isWork && deltaSeconds > 0) state.studyTimeTotal += deltaSeconds;
    } else { // Timer mode (Count-up)
      state.remainSec = elapsedRealSeconds;
      if(deltaSeconds > 0) state.studyTimeTotal += deltaSeconds;
    }
    
    state.startTimeStamp = 0; 
    state.lastUpdateTimestamp = 0; 

    updateTimerUI();
    // updateCharacterAndWindowImages(); // [삭제] 그림 애니메이션은 별도의 500ms 타이머가 담당
    window.__presence_broadcastNow?.();
    
    // [유지] 정지 시 제목을 기본값으로 복구
    document.title = `Studywithme`;
  }
  
  /* [유지] 타이머 리셋 */
  function resetTimer(){
    stopTimer();
    state.isWork=true;
    state.remainSec = (state.mode==='pomodoro') ? state.workSec : 0;
    state.startTimeStamp = 0;
    state.lastUpdateTimestamp = 0;
    updateTimerUI();
    // updateCharacterAndWindowImages(); // [삭제] 그림 애니메이션은 별도의 500ms 타이머가 담당
    
    // [유지] 리셋 시 제목을 기본값으로 복구
    document.title = `Studywithme`;
  }
  
  document.getElementById("startPause").addEventListener("click", ()=> state.running?stopTimer():startTimer());
  document.getElementById("reset").addEventListener("click", resetTimer);
  function updateCyclesBtn(){ 
      const text = `${state.completedCycles}/${state.totalCycles}회`;
      cyclesBtn.textContent = text;
      cyclesBtn.title = text;
  }

  function updateWindowToggleUI(){ 
      const show = state.windowVisible;
      toggleWindowBtn.textContent = getTranslation(show ? 'window_show' : 'window_hide');
      windowBox.style.display = show ? "" : "none"; 
  }
  function updateCharacterToggleUI(){ 
      const show = state.characterVisible;
      toggleCharacterBtn.textContent = getTranslation(show ? 'character_show' : 'character_hide');
      characterBox.style.display = show ? "" : "none"; 
  }

  function setupLayoutDrag(){
    const APP = document.getElementById('app');
    const DRAG_IDS = ['timer','board','window','character','music-controls'];
    const RESIZE_IDS = ['window','character'];
    const Z_TOP_CAP = 8999;

    const registry = new Map();
    // window.editOn 전역 변수화 (layoutEditBtn 텍스트 업데이트를 위해)
    window.editOn = false; 
    let zTop = 100;

    const posKey = id => `pos-${id}`;

    function restorePositionsOnLoad(){
      DRAG_IDS.forEach(id=>{
        const el = document.getElementById(id);
        if(!el) return;
        const saved = localStorage.getItem(posKey(id));
        if(saved){
          const {left, top, width} = JSON.parse(saved);
          absolutize(el);
          place(el, left, top, width);
        }
      });
    }

    function absolutize(el){
      if(registry.has(el.id)) return;
      const rect = el.getBoundingClientRect();
      const appRect = APP.getBoundingClientRect();

      const ph = document.createElement('div');
      ph.style.width  = rect.width + 'px';
      ph.style.height = rect.height + 'px';
      ph.style.visibility = 'hidden';
      el.parentNode.insertBefore(ph, el);

      el.style.position = 'absolute';
      el.style.width    = rect.width + 'px';
      el.style.left     = (rect.left - appRect.left + window.scrollX) + 'px';
      el.style.top      = (rect.top  - appRect.top  + window.scrollY) + 'px';
      el.style.zIndex   = (parseInt(el.style.zIndex||'10',10));
      APP.appendChild(el);

      if(el.classList.contains('resizable') && !el.querySelector('.resizer')){
        const rz = document.createElement('div');
        rz.className = 'resizer';
        el.appendChild(rz);
      }

      registry.set(el.id, {el, placeholder: ph});
    }

    function place(el, left, top, width){
      if(width) el.style.width = width + 'px';
      el.style.left = left + 'px';
      el.style.top  = top  + 'px';
    }

    function setEditable(on){
      window.editOn = on;
      document.getElementById('app').classList.toggle('edit-on', on);
      layoutEditBtn.textContent = getTranslation(on ? 'layout_edit_on' : 'layout_edit_off');

      DRAG_IDS.forEach(id=>{
        const el = document.getElementById(id);
        if(!el) return;

        if(on){
          if(!registry.has(id)) absolutize(el);
          el.classList.add('draggable');
          enableDrag(el);
          if(RESIZE_IDS.includes(id)) enableResize(el);
        }else{
          el.classList.remove('draggable');
          disableDrag(el);
          if(RESIZE_IDS.includes(id)) disableResize(el);
        }
      });

      document.querySelectorAll('.prop').forEach(el=>{
        if(on){ enableDrag(el); enableResize(el); }
        else  { disableDrag(el); disableResize(el); }
      });
    }

    window.__layoutSetEditable = setEditable;
    window.__layoutFocus = (pid)=>{
      const el = document.querySelector(`.prop[data-pid="${pid}"]`);
      if(!el) return;
      el.style.zIndex = Math.min(++zTop, Z_TOP_CAP);
      el.classList.add('selected');
      setTimeout(()=> el.classList.remove('selected'), 1500);
      el.scrollIntoView?.({behavior:'smooth', block:'center', inline:'center'});
    };

    function enableDrag(el){
      if(el._dragBound) return;
      const onDown = (e)=>{
        if(!window.editOn) return;
        if(e.target.classList && e.target.classList.contains('resizer')) return;

        e.preventDefault();
        el.classList.add('dragging');
        el.style.zIndex = Math.min(++zTop, Z_TOP_CAP);

        const startX = (e.touches? e.touches[0].clientX : e.clientX);
        const startY = (e.touches? e.touches[0].clientY : e.clientY);
        const startLeft = parseFloat(el.style.left)||0;
        const startTop  = parseFloat(el.style.top)||0;

        const move = (ev)=>{
          const cx = (ev.touches? ev.touches[0].clientX : ev.clientX);
          const cy = (ev.touches? ev.touches[0].clientY : ev.clientY);
          const dx = cx - startX;
          const dy = cy - startY;
          place(el, startLeft + dx, startTop + dy);
        };
        const up = ()=>{
          document.removeEventListener('pointermove', move);
          document.removeEventListener('pointerup', up);
          document.removeEventListener('touchmove', move);
          document.removeEventListener('touchend', up);
          el.classList.remove('dragging');
          persistPos(el);
        };

        document.addEventListener('pointermove', move);
        document.addEventListener('pointerup', up);
        document.addEventListener('touchmove', move, {passive:false});
        document.addEventListener('touchend', up);
      };
      el.addEventListener('pointerdown', onDown);
      el.addEventListener('touchstart', onDown, {passive:false});
      el._dragBound = onDown;
    }
    function disableDrag(el){
      if(!el._dragBound) return;
      el.removeEventListener('pointerdown', el._dragBound);
      el.removeEventListener('touchstart', el._dragBound);
      delete el._dragBound;
    }

    function enableResize(el){
      if(el._resizeBound) return;
      const onDown = (e)=>{
        if(!window.editOn) return;
        if(!e.target.classList || !e.target.classList.contains('resizer')) return;
        e.preventDefault();
        el.classList.add('dragging');
        el.style.zIndex = Math.min(++zTop, Z_TOP_CAP);

        const startX = (e.touches? e.touches[0].clientX : e.clientX);
        const startWidth = parseFloat(el.style.width) || el.getBoundingClientRect().width;

        const move = (ev)=>{
          const cx = (ev.touches? ev.touches[0].clientX : ev.clientX);
          const dx = cx - startX;
          const newW = Math.max(120, startWidth + dx);
          el.style.width = newW + 'px';
        };
        const up = ()=>{
          document.removeEventListener('pointermove', move);
          document.removeEventListener('pointerup', up);
          document.removeEventListener('touchmove', move);
          document.removeEventListener('touchend', up);
          el.classList.remove('dragging');
          persistPos(el);
        };

        document.addEventListener('pointermove', move);
        document.addEventListener('pointerup', up);
        document.addEventListener('touchmove', move);
        document.addEventListener('touchend', up);
      };
      el.addEventListener('pointerdown', onDown);
      el.addEventListener('touchstart', onDown, {passive:false});
      el._resizeBound = onDown;
    }
    function disableResize(el){
      if(!el._resizeBound) return;
      el.removeEventListener('pointerdown', el._resizeBound);
      el.removeEventListener('touchstart', el._resizeBound);
      delete el._resizeBound;
    }

    function persistPos(el){
      const left = parseFloat(el.style.left)||0;
      const top  = parseFloat(el.style.top)||0;
      const width= parseFloat(el.style.width)||el.getBoundingClientRect().width;

      if(el.classList.contains('prop')){
        const id = el.dataset.pid;
        const idx = state.props.findIndex(p=>p.id===id);
        if(idx>=0){ state.props[idx].left=left; state.props[idx].top=top; state.props[idx].width=width; }
        localStorage.setItem('props-v1', JSON.stringify(state.props));
      }else{
        localStorage.setItem(`pos-${el.id}`, JSON.stringify({left, top, width}));
      }
    }

    layoutResetBtn.addEventListener('click', ()=>{
      // [유지] 리셋 전 정확한 remainSec을 계산하여 저장
      const snap = {
        mode: state.mode, isWork: state.isWork, running: state.running,
        workSec: state.workSec, restSec: state.restSec, 
        remainSec: calculateAccurateRemaining(),
        totalCycles: state.totalCycles, completedCycles: state.completedCycles
      };
      sessionStorage.setItem('timer-keep', JSON.stringify(snap));

      DRAG_IDS.forEach(id=> localStorage.removeItem(`pos-${id}`));
      localStorage.removeItem('props-v1');
      localStorage.removeItem('ui-window-visible');
      localStorage.removeItem('ui-character-visible');
      location.reload();
    });

    layoutEditBtn.addEventListener('click', ()=> setEditable(!window.editOn));
    restorePositionsOnLoad();
  }

  function renderProps(){
    propsLayer.innerHTML = '';
    state.props.forEach(p=>{
      const el = document.createElement('div');
      el.className = 'prop resizable';
      el.dataset.pid = p.id;
      el.style.left = (p.left ?? 40) + 'px';
      el.style.top  = (p.top  ?? 40) + 'px';
      el.style.width= (p.width?? 120) + 'px';
      el.style.zIndex = 80;

      const img = document.createElement('img');
      img.src = p.url; img.alt = 'prop';
      el.appendChild(img);

      const rz = document.createElement('div'); rz.className='resizer'; el.appendChild(rz);
      propsLayer.appendChild(el);
    });
    renderPropList();
  }
  function renderPropList(){
    propList.innerHTML = '';
    const fragment = document.createDocumentFragment();
    state.props.forEach(p=>{
      const row = document.createElement('div'); row.className='todo';
      const tx  = document.createElement('div'); tx.className='txt';
      tx.innerHTML = `<img src="${p.url}" style="width:28px;height:28px;object-fit:contain;vertical-align:middle;margin-right:.5rem"> ${p.id}`;
      const del = document.createElement('button'); del.className='del'; del.textContent=getTranslation('delete');
      del.addEventListener('click', ()=>{
        const idx = state.props.findIndex(x=>x.id===p.id);
        if(idx>=0) state.props.splice(idx,1);
        localStorage.setItem('props-v1', JSON.stringify(state.props));
        renderProps();
      });
      row.append(tx, del);
      fragment.appendChild(row);
    });
    propList.appendChild(fragment);
  }
  function addProp(url, center=true, opts={}){
    const id = 'prop-' + Date.now().toString(36);
    const MINW = 120;
    let left=40, top=40, width=MINW;
    if(center){
      const appRect = document.getElementById('app').getBoundingClientRect();
      left = Math.max(0, Math.floor((appRect.width - width)/2));
      top  = Math.max(0, Math.floor((appRect.height - width)/2));
    }
    state.props.push({id, url, left, top, width});
    localStorage.setItem('props-v1', JSON.stringify(state.props));
    renderProps();

    if(opts.autoEdit){
      window.__layoutSetEditable?.(true);
      setTimeout(()=> window.__layoutFocus?.(id), 0);
    }
  }

  init();
</script>

<!-- ===== Supabase Presence (실시간) ===== -->
<script type="module">
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = "https://jvpasqknlkeyshrevqpg.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imp2cGFzcWtubGtleXNocmV2cXBnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkwNDQyOTMsImV4cCI6MjA3NDYyMDI5M30.7zKRGoBFjoWksoRXjUj8n4KzLXdiF86lZwneNdZNF5k";

const presencePanel = document.getElementById("presencePanel");
const meNickEl      = document.getElementById("meNick");
const presenceList  = document.getElementById("presenceList");
const presenceToggle= document.getElementById("presenceToggle");
const nicknameInput = document.getElementById("nickname");
const applyNick     = document.getElementById("applyNick"); // 추가된 닉네임 적용 버튼

// --- smartphone detector (여기에 추가) ---
function isSmartphone(){
  const ua = navigator.userAgent || navigator.vendor || window.opera || "";
  const looksMobileUA = /iPhone|iPod|Android.+Mobile|Mobi/i.test(ua);
  const smallViewport = Math.min(window.innerWidth, window.innerHeight) <= 820; // 태블릿 제외용 여유값
  return looksMobileUA && smallViewport;
}

  
let supabase = null;
let channel  = null;
let heartbeat= null;

/* [수정] 닉네임이 있으면 자동 연결 */
window.addEventListener('load', ()=>{ 
    const savedNick = localStorage.getItem("nickname");
    // 닉네임 로드 및 UI 업데이트
    if (savedNick) {
        nicknameInput.value = savedNick;
        meNickEl.textContent = savedNick; // 닉네임 UI에 표시
    }
    
    // 닉네임이 있고, 설정 준비가 되었으면 goOnline() 시도
    if (cfgReady() && savedNick && savedNick.trim() !== "") { 
        goOnline(); 
    }
});

function cfgReady(){
  return SUPABASE_URL.startsWith("https://") && !!SUPABASE_ANON_KEY;
}
function getSnapshot(){
  const st = window.state || {};
  let study = null;
  
  // 1. 공부 시간 공개가 ON일 때만 studyTimeTotal 전송 (롤백된 로직)
  if(st.shareStudy){
    // [유지] 실시간 업데이트 시 studyTimeTotal을 정확히 반영
    const now = Date.now();
    let currentStudyTotal = st.studyTimeTotal;
    
    // 타이머가 작동 중이고 집중중/카운트업 모드라면, 현재까지의 델타를 더해줌
    if (st.running && (st.mode === 'timer' || st.isWork)) {
        // studyTimeTotal은 마지막 업데이트 시점(lastUpdateTimestamp)을 기준으로 누적됨.
        // 여기서는 lastUpdateTimestamp 이후 경과된 시간만 추가
        const deltaSeconds = Math.floor((now - st.lastUpdateTimestamp) / 1000);
        currentStudyTotal += deltaSeconds;
    }
    
    study = currentStudyTotal || 0;
  }
  
  let status = "idle"; // 기본 상태를 'idle'로 설정
  
  if (st.running) {
      // 타이머가 작동 중일 때만 상태를 work/break/timer로 설정
      status = (st.mode === 'pomodoro') ? (st.isWork ? "work" : "break") : "timer";
  }
  
  return { status, study };
}
function fmtMin(sec){
    const s = sec|0; // 초 정수화
    const h = Math.floor(s/3600);
    const m = Math.floor((s%3600)/60);
    
    // 1분 미만은 0분으로 표시
    if (s < 60) return `0${getTranslation('min_short')}`; 
    
    // 1시간 이상일 경우 "X시간 Y분" 포맷
    if(h > 0) return `${h}${getTranslation('hour_short')} ${m}${getTranslation('min_short')}`;
    
    // 1시간 미만일 경우 "Y분" 포맷
    return `${m}${getTranslation('min_short')}`;
}

function getTranslation(key) {
    const lang = window.state.lang;
    // 윈도우 객체에 TRANSLATIONS가 있을 경우 사용 (실제 앱 로직)
    if (window.TRANSLATIONS) {
        return window.TRANSLATIONS[lang][key] || window.TRANSLATIONS['en'][key] || key;
    }
    // 디버그 용 기본값
    const debugTranslations = {
        ko: { status_work: "집중중", status_break: "휴식중", status_idle: "대기중", timer_mode: "타이머", hour_short: "시간", min_short: "분", no_one_online: "아직 아무도 없어요" },
        en: { status_work: "Focusing", status_break: "Resting", status_idle: "Idle", timer_mode: "Timer Mode", hour_short: "h", min_short: "m", no_one_online: "No one online yet" }
    };
    return debugTranslations[lang]?.[key] || key;
}

function renderOnline(presenceState){
  const items = [];
  
  for(const [nick, metas] of Object.entries(presenceState)){
    const meta = metas[metas.length-1] || {};
    const status = meta?.status || "idle";
    // study가 null이면 공개 OFF, number면 공개 ON
    const study  = typeof meta?.study  === "number" ? meta.study  : null; 

    let statusKey = '';
    let dotClass = 'dot';
    
    // 1. 상태 및 점 색상 결정
    if (status === 'work') {
        statusKey = 'status_work';
        dotClass += ' work';
    } else if (status === 'break') {
        statusKey = 'status_break';
        dotClass += ' break';
    } else if (status === 'timer') {
        statusKey = 'timer_mode';
        dotClass += ' work';
    } else { // status === 'idle' (타이머 정지/미시작 상태)
        statusKey = 'status_idle';
    }

    let rightTxt = getTranslation(statusKey);
    
    // 2. 공부시간 공개 여부에 따라 텍스트 결정
    if (study !== null) {
      // 공부시간 공개 ON: 상태 + 누적 공부 시간
      const studyTimeText = fmtMin(study);
      // [수정] "집중중 · 누적 57분" 형태로 표시
      rightTxt = `${getTranslation(statusKey)} · 누적 ${studyTimeText}`; 
    } else {
        // 공부시간 공개 OFF: 상태 텍스트만 유지 (rightTxt = getTranslation(statusKey))
    }
    
    items.push(
      `<div class="person">
         <div><span class="${dotClass}"></span><span class="nick">${nick}</span></div>
         <div style="opacity:.8">${rightTxt}</div>
       </div>`
    );
  }
  
  const noOneOnlineText = getTranslation('no_one_online')
  
  // 닉네임이 'anonymous'인 사용자는 필터링 (로컬 유저가 닉네임 설정을 하지 않았을 경우)
  const filteredItems = items.filter(item => !item.includes('<span class="nick">anonymous</span>'));

  presenceList.innerHTML = filteredItems.slice(0,5).join("") || `<div style="opacity:.8">${noOneOnlineText}</div>`;
}

window.__presence_broadcastNow = async function(){
  if(!channel) return;
  try{ await channel.track(getSnapshot()); }catch{}
};
window.__presence_goOnline = goOnline;
window.__presence_goOffline = goOffline;

async function goOnline(){
  if(!cfgReady()){ 
      console.error("Supabase configuration not ready.");
      presencePanel.style.display = "none";
      return; 
  }
  if(!supabase) supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  const myNick = (nicknameInput.value || "").trim();
  
  // 닉네임이 유효하지 않으면 연결하지 않고 종료
  if (myNick === "" || myNick === "anonymous") {
      goOffline(); // 연결되어 있을 경우 끊음
      return; 
  }
  
  // 닉네임 변경/설정 로직
  localStorage.setItem("nickname", myNick); 
  meNickEl.textContent = myNick;
  presencePanel.style.display = "block";

  // 채널이 이미 존재하거나 닉네임이 변경되었다면 재연결
  if (channel) {
      await channel.unsubscribe();
      if(heartbeat){ clearInterval(heartbeat); heartbeat = null; }
  }

  channel = supabase.channel("studyroom", { config: { presence: { key: myNick } } });
  channel.on("presence", { event: "sync" }, ()=>{ renderOnline(channel.presenceState()); });

  channel.subscribe(async (status)=>{
    if(status === "SUBSCRIBED"){
      try{ await channel.track(getSnapshot()); }catch{}
      // [유지] heartbeat는 그대로 15초 간격 유지 (실시간 반영 위함)
      heartbeat = setInterval(async ()=>{ 
          try{ await channel.track(getSnapshot()); }catch{} 
      }, 15000);
    }
  });

  presenceToggle.textContent = getTranslation('public_on');
}
async function goOffline(){
  if(heartbeat){ clearInterval(heartbeat); heartbeat = null; }
  if(channel){ try{ await channel.unsubscribe(); }catch{} }
  channel = null;
  presenceToggle.textContent = getTranslation('public_off');
  presencePanel.style.display = "none";
  presenceList.innerHTML = "";
}

// 닉네임 적용 버튼 이벤트 리스너
applyNick.addEventListener('click', goOnline);

// [수정] 닉네임 입력 시 localStorage 업데이트 및 UI 반영만. 연결은 적용 버튼으로 분리.
nicknameInput.addEventListener('input', ()=>{
    const currentNick = nicknameInput.value.trim();
    localStorage.setItem("nickname", currentNick);
    meNickEl.textContent = currentNick; // 즉시 UI 반영
    if (currentNick === "" && channel) {
        // 닉네임이 비어 있고 현재 연결되어 있다면, 오프라인으로 전환
        goOffline(); 
    }
});


presenceToggle?.addEventListener("click", async ()=>{
  if(!channel){ await goOnline(); } else { await goOffline(); }
});
</script>
</body>
</html>
